#!/usr/bin/env python3
import os
import re
import sys
from pathlib import Path

# ------------------------------------------------------------
# Step 1 — Parse abstract interface class from C++ header
# ------------------------------------------------------------
import re

def extract_braced_block(text, start_index):
    """
    Returns the substring between matching braces starting at text[start_index],
    handling nested braces correctly.

    Parameters:
        text (str): The full text to scan.
        start_index (int): Index of the opening '{' character.

    Returns:
        (block_text, end_index): 
            block_text is the string between braces (excluding the braces).
            end_index is the index *after* the matching '}'.
    
    Raises:
        ValueError: if braces are unbalanced or start_index is invalid.
    """
    if start_index < 0 or start_index >= len(text) or text[start_index] != '{':
        raise ValueError("start_index must point to an opening brace '{'")

    brace_count = 1
    i = start_index + 1
    while i < len(text) and brace_count > 0:
        if text[i] == '{':
            brace_count += 1
        elif text[i] == '}':
            brace_count -= 1
        i += 1

    if brace_count != 0:
        raise ValueError("Unbalanced braces in input text")

    return text[start_index + 1 : i - 1], i


def parse_interface(header_text):
    """
    Finds the first C++ abstract interface class (not enum/struct/union) in header_text
    and returns its name and body text (without braces).
    """
    # Regex to find a non-enum/struct/union class declaration
    class_match = re.search(r'(?<!enum\s)\bclass\s(\w+).*\s*{', header_text)
    if not class_match:
        raise ValueError("No abstract class found")

    interface_name = class_match.group(1)
    start_index = class_match.end() - 1  # points to '{'

    class_body, _ = extract_braced_block(header_text, start_index)

    # Match pure virtual methods
    method_pattern = re.compile(
        r'virtual\s+([\w:<>&\s*\[\]]+?)\s+(\w+)\s*\(([^)]*)\)\s*(const)?\s*=\s*0\s*;',
        re.MULTILINE
    )

    methods = []
    for m in method_pattern.finditer(class_body):
        return_type, name, args, const = m.groups()
        methods.append({
            "return_type": return_type.strip(),
            "name": name.strip(),
            "args": args.strip(),
            "const": bool(const)
        })

    if not methods:
        raise ValueError(f"No abstract class found (no pure virtual methods) looking in {class_body}")

    return interface_name, methods


# ------------------------------------------------------------
# Step 2 — Generate bridge header and source files
# ------------------------------------------------------------
TPL_H = """//------------------------------------------------------------------------------
//  This file is auto-generated by StableInterfaceGenerator.
//
//  Pattern: **Hourglass ABI Pattern**
//  ----------------------------------
//  The Hourglass ABI Pattern is a robust approach for maintaining binary
//  compatibility (ABI stability) across module or library boundaries, even as
//  interfaces evolve. It is named for its "narrow waist": a minimal, stable
//  interface (the "hourglass") that separates clients from implementation
//  details, allowing both sides to change independently as long as the contract
//  at the waist is preserved.
//
//  In this design, the hourglass is formed by:
//    • A stable abstract interface ({interface_name}) that defines the contract.
//    • A bridge/proxy ({interface_name}Bridge/Proxy) that forwards calls and hides
//      implementation details using opaque pointers (Pimpl).
//    • Concrete implementations that can evolve freely behind the bridge.
//
//  Key properties:
//    - The bridge exposes only the stable interface to clients.
//    - Clients and implementations can be built against different versions of
//      the interface, as long as old methods are preserved.
//    - New methods can be added to the interface (at any position), provided
//      existing methods are not removed or reordered.
//    - The bridge ensures that only supported methods are called, preventing
//      undefined behavior.
//
//  Example structure:
//
//      +-----------------+        +---------------------+
//      |  Client code    | -----> |  {interface_name}Proxy/Bridge  |  (hourglass waist)
//      +-----------------+        |  owns unique_ptr<{interface_name}> |
//                                  +---------------------+
//                                                 |
//                                                 v
//                                        +-----------------+
//                                        |  {interface_name} (abstract) |
//                                        +-----------------+
//                                                 |
//                                                 v
//                                        +-----------------+
//                                        |  Impl           |
//                                        +-----------------+
//
//  Benefits:
//    - Preserves binary compatibility as interfaces evolve.
//    - Hides internal class layouts and implementation details.
//    - Allows independent evolution of client and implementation code.
//    - Enables safe addition of new virtual methods to the interface.
//
//  Notes:
//    - Generated bridge functions are non-virtual and inline forwarders.
//    - As long as old methods are preserved, new methods can be added to
//      {interface_name}.h without breaking existing clients.
// 
//  References:
//    - "Hourglass Pattern" (see LLVM, Qt, and other large C++ projects)
//    - https://www.akkadia.org/drepper/dsohowto.pdf (Ulrich Drepper, "How To Write Shared Libraries")
//------------------------------------------------------------------------------

#pragma once
#include <memory>
#include "{interface_name}.h"

// Forward declaration
class {interface_name}Bridge;

// Proxy that inherits from {interface_name}
class {interface_name}Proxy : public {interface_name} {{
public:
    explicit {interface_name}Proxy(std::unique_ptr<{interface_name}Bridge>&& bridge);
   
{override_methods_decl}
private:
    std::unique_ptr<{interface_name}Bridge> impl_;
}};

// Factory that returns a stable {interface_name}
std::unique_ptr<{interface_name}> CreateStable{interface_name}(std::unique_ptr<{interface_name}>&& impl);
"""

TPL_CPP = """//------------------------------------------------------------------------------
//  This file is auto-generated by StableInterfaceGenerator.
//
//  Pattern: **Hourglass ABI Pattern**
//  (see full description in {interface_name}.h)
//------------------------------------------------------------------------------

#include "{interface_name}Bridge.h"

class {interface_name}Bridge {{
public:
    explicit {interface_name}Bridge(std::unique_ptr<{interface_name}>&& impl)
        : impl_(std::move(impl)) {{}}
{bridge_methods_impl} 

private:
    std::unique_ptr<{interface_name}> impl_;
}};

// Proxy definitions
{interface_name}Proxy::{interface_name}Proxy(std::unique_ptr<{interface_name}Bridge>&& impl)
    : impl_(std::move(impl)) {{}}

{proxy_methods_impl}

// Factory — creates the proxy
std::unique_ptr<{interface_name}> CreateStable{interface_name}(std::unique_ptr<{interface_name}>&& impl) 
{{
    auto bridge = std::make_unique<{interface_name}Bridge>(std::move(impl));
    return std::make_unique<{interface_name}Proxy>(std::move(bridge));
}}
"""

# ------------------------------------------------------------
# Step 3 — Render methods
# ------------------------------------------------------------
def generate_override_methods_decl(methods):
    result = []
    for m in methods:
        const_str = " const" if m["const"] else ""
        # No 'virtual', add 'override'
        result.append(f"    {m['return_type']} {m['name']}({m['args']}){const_str} override;")
    return "\n".join(result)


def generate_forwarding_methods_impl(prepend_name, append_name, methods):
    result = []
    for m in methods:
        const_str = " const" if m["const"] else ""
        ret = "" if m["return_type"] == "void" else "return "
        args = m["args"]
        arg_names = ", ".join([a.strip().split()[-1] for a in args.split(",") if a.strip()]) if args else ""
        result.append(
            f"    {m['return_type']} {prepend_name}{m['name']}({args}){const_str} {append_name} {{ "
            f"{ret}impl_->{m['name']}({arg_names}); }}\n"
        )
    return "\n".join(result)


# ------------------------------------------------------------
# Step 4 — Main generation
# ------------------------------------------------------------
def generate_files(header_file):
    try:
        with open(header_file, "r", encoding="utf-8") as f:
            header_text = f.read()
    except FileNotFoundError:
        print(f"[StableInterfaceGenerator] ERROR: Header file '{header_file}' not found.")
        return
    except Exception as e:
        print(f"[StableInterfaceGenerator] ERROR: Failed to read '{header_file}': {e}")
        return

    try:
        interface_name, methods = parse_interface(header_text)
    except ValueError as e:
        print(f"[StableInterfaceGenerator] {e}")
        return

    stable_name = interface_name + "Stable"
    override_methods_decl = generate_override_methods_decl(methods)
    bridge_methods_impl = generate_forwarding_methods_impl("", "override", methods)
    proxy_methods_impl = generate_forwarding_methods_impl(f"{interface_name}Proxy::", "", methods)
    h_out = TPL_H.format(
        interface_name=interface_name,
        override_methods_decl=override_methods_decl,
    )

    cpp_out = TPL_CPP.format(
        interface_name=interface_name,
        bridge_methods_impl=bridge_methods_impl,
        proxy_methods_impl=proxy_methods_impl,
    )

    header_dir = Path(header_file).parent / "stable"
    header_dir.mkdir(exist_ok=True)

    h_path = header_dir / f"{stable_name }.h"
    cpp_path = header_dir / f"{stable_name }.cpp"

    with open(h_path, "w", encoding="utf-8") as f:
        f.write(h_out)
    with open(cpp_path, "w", encoding="utf-8") as f:
        f.write(cpp_out)

    print(f"[StableInterfaceGenerator] Generated {h_path.name} and {cpp_path.name}")


# ------------------------------------------------------------
# Step 5 — Command line entry
# ------------------------------------------------------------
if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python StableInterfaceGenerator.py <interface-header>")
        sys.exit(1)

    generate_files(sys.argv[1])
